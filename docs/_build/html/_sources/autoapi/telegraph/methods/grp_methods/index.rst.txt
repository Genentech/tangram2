:py:mod:`telegraph.methods.grp_methods`
=======================================

.. py:module:: telegraph.methods.grp_methods


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   telegraph.methods.grp_methods.GroupMethodClass
   telegraph.methods.grp_methods.ThresholdGroup
   telegraph.methods.grp_methods.AssociationScore
   telegraph.methods.grp_methods.QuantileGroup
   telegraph.methods.grp_methods.SpotBasedGroup
   telegraph.methods.grp_methods.DistanceBasedGroup




.. py:class:: GroupMethodClass(*args, **kwargs)


   Bases: :py:obj:`telegraph.methods._methods.MethodClass`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:method:: run(input_dict: Dict[str, Any], *args, **kwargs) -> Dict[str, pandas.DataFrame]
      :classmethod:
      :abstractmethod:



.. py:class:: ThresholdGroup(*args, **kwargs)


   Bases: :py:obj:`GroupMethodClass`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: ins
      :value: ['X_from', ('X_to_pred', 'X_to'), 'T']



   .. py:attribute:: outs
      :value: ['D_to', 'D_from']



   .. py:method:: run(input_dict: Dict[str, Any], feature_name: List[str] | str, thres_t: float | Tuple[float, float] = 0.5, thres_x: float | Tuple[float, float] = 0.5, add_complement: bool = True, **kwargs) -> pandas.DataFrame
      :classmethod:



.. py:class:: AssociationScore(*args, **kwargs)


   Bases: :py:obj:`GroupMethodClass`

   Association Score between

   how strongly is observation i in 'from' associated
   with feature f in 'from'


   Calculates `Q` where, Q_{if} indicates how strongly associated
   observation i in 'from' is with feature f in 'to_pred'.


   We use the formula: :math:`Q = T^t \cdot X_to_pred = T^t \cdot (T \cdot X_{to\_pred})`

   The dimensions for the objects are:

   X_from : [n_from] x [n_var] (e.g., spatial gene expression)
   X_to_pred : [n_to] x [n_var] (e.g., single cell gene expression)
   T : [n_to] x [n_from] (e.g., map of single cells to visium spots)
   Q : [n_from] x [n_var]

   Q should be a pd.DataFrame object


   .. py:attribute:: ins
      :value: ['X_from', 'T', ('X_to', 'X_to_pred')]



   .. py:attribute:: outs
      :value: ['D_from']



   .. py:method:: run(input_dict: Dict[str, Any], feature_name: List[str] | str | None = None, **kwargs) -> pandas.DataFrame
      :classmethod:



.. py:class:: QuantileGroup(*args, **kwargs)


   Bases: :py:obj:`GroupMethodClass`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: ins
      :value: ['X_from', 'X_to', 'T']



   .. py:attribute:: outs
      :value: ['D_to', 'D_from']



   .. py:method:: run(input_dict: Dict[str, Any], feature_name: List[str] | str, q_t: float | Tuple[float, float] = 0.25, q_x: float | Tuple[float, float] = 0.25, subset_covs: Dict[str, List[str]] | None = None, **kwargs) -> pandas.DataFrame
      :classmethod:



.. py:class:: SpotBasedGroup(*args, **kwargs)


   Bases: :py:obj:`GroupMethodClass`

   Helper class that provides a standard way to create an ABC using
   inheritance.

   .. py:attribute:: ins
      :value: ['X_from', 'T']



   .. py:attribute:: outs
      :value: ['D_to', 'D_from']



   .. py:method:: run(input_dict: Dict[str, Any], feature_name: List[str] | str, p_thres: float = 0.8, add_complement: bool = True) -> Dict[str, pandas.DataFrame]
      :classmethod:



.. py:class:: DistanceBasedGroup(*args, **kwargs)


   Bases: :py:obj:`GroupMethodClass`

   Grouping Method based on distance between observations

   This methods is primarily recommended when using single cell resolution spatial data (e.g.,
   Xenium, CosMX, and Vizgen). It allows you to specify a reference feature and a quantile, all
   cells in X_to expressing that feature at a level above the quantile will be considered as a
   "high" group, cells below the quantile threshold are "low". The K nearest neighbors of each
   high cell that are not in the high group will be considered as adjacent cells to that feature.


   .. py:attribute:: ins
      :value: [('X_to_pred', 'X_to'), 'S_to']



   .. py:attribute:: outs
      :value: ['D_to', 'D_from']



   .. py:method:: run(input_dict: Dict[str, Any], feature_name: List[str] | str, q_high: float | Tuple[float, float] = 0.95, add_complement: bool = True, k=5, **kwargs) -> Dict[str, pandas.DataFrame]
      :classmethod:

      :param input_dict: standard input dictionary
      :param feature_name: name of feature to base high/low groups on
      :param q_high: quantile to separate feature expression w.r.t.
      :param add_complement: include both high/low and adj/nadj groups in output design matrix
      :param k: number of spatial neighbors

      :returns: Dictionary with design matrix for to (D_to)
