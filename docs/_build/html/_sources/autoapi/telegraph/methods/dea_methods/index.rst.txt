telegraph.methods.dea_methods
=============================

.. py:module:: telegraph.methods.dea_methods


Classes
-------

.. autoapisummary::

   telegraph.methods.dea_methods.DEAMethodClass
   telegraph.methods.dea_methods.ScanpyDEA
   telegraph.methods.dea_methods.GLMDEA
   telegraph.methods.dea_methods.LRDEA
   telegraph.methods.dea_methods.RandomFeatureDEA
   telegraph.methods.dea_methods.HVGFeatureDEA


Module Contents
---------------

.. py:class:: DEAMethodClass(*args, **kwargs)

   Bases: :py:obj:`telegraph.methods._methods.MethodClass`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:method:: run(input_dict: Dict[str, Any], **kwargs) -> Dict[str, Dict[str, pandas.DataFrame]]
      :classmethod:

      :abstractmethod:



.. py:class:: ScanpyDEA(*args, **kwargs)

   Bases: :py:obj:`DEAMethodClass`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: ins
      :value: ['D_from', 'D_to', 'X_from', 'X_to_pred']



   .. py:attribute:: outs
      :value: ['DEA']



   .. py:method:: run(input_dict: Dict[str, Any], groups: List[str] | str = 'all', method: str = 'wilcoxon', sort_by: str = 'pvals_adj', pval_cutoff: float | None = None, mode: Literal['pos', 'neg', 'both'] = 'both', method_kwargs: Dict[str, Any] = {}, normalize: bool = False, subset_features: Dict[str, List[str]] | Dict[str, str] | None = None, min_group_obs: int = 2, target: List[str] | str = 'both', **kwargs) -> Dict[str, Dict[str, pandas.DataFrame]]
      :classmethod:



.. py:class:: GLMDEA(*args, **kwargs)

   Bases: :py:obj:`DEAMethodClass`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: ins
      :value: ['D_from', 'D_to', 'X_from', 'X_to']



   .. py:attribute:: outs
      :value: ['DEA']



   .. py:method:: run(input_dict: Dict[str, Any], family: str = 'negative.binomial', target: Literal['to', 'from', 'both'] = 'both', use_covariates: List[str] | str | None = None, drop_covariates: List[str] | str | None = None, merge_covariates: List[List[str]] | None = None, use_pred: bool | Dict[str, bool] = True, subset_features: List[str] | str | None = None, use_obs_with_covariates: bool = False, fit_intercept: bool = False, mht_method: str = 'fdr_bh', **kwargs) -> Dict[str, Dict[str, pandas.DataFrame]]
      :classmethod:



.. py:class:: LRDEA(*args, **kwargs)

   Bases: :py:obj:`DEAMethodClass`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: ins
      :value: [('D_from', 'D_to'), ('X_from', 'X_to', 'X_to_pred')]



   .. py:attribute:: outs
      :value: ['DEA']



   .. py:method:: run(input_dict: Dict[str, Any], covariates: Dict[str, str] | str | List[str], sort_by: str = 'pvals_adj', pval_cutoff: float | None = None, random_state: int = 0, C: float = 1, max_iter: int = 100, target: Literal['both', 'to', 'from'] = 'from', **kwargs) -> Dict[str, Dict[str, pandas.DataFrame]]
      :classmethod:



.. py:class:: RandomFeatureDEA(*args, **kwargs)

   Bases: :py:obj:`DEAMethodClass`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: ins
      :value: [('X_from', 'X_to', 'X_to_pred')]



   .. py:attribute:: outs
      :value: ['DEA']



   .. py:method:: get_random_dea(names, lfc_min_max: Tuple[float, float] = (-2, 2))
      :classmethod:



   .. py:method:: run_with_adata(adata: anndata.AnnData)
      :classmethod:



   .. py:method:: run(input_dict: Dict[str, Any], *args, **kwargs)
      :classmethod:



.. py:class:: HVGFeatureDEA(*args, **kwargs)

   Bases: :py:obj:`DEAMethodClass`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: ins
      :value: [('X_from', 'X_to', 'X_to_pred')]



   .. py:attribute:: outs
      :value: ['DEA']



   .. py:method:: get_hvg_dea(X_df, n_bins: int = 20)
      :classmethod:



   .. py:method:: run_with_adata(adata: anndata.AnnData, subset_col: str, subset_labels: str | List[str] | None = None, layer: str | None = None)
      :classmethod:



   .. py:method:: run(input_dict: Dict[str, Any], *args, **kwargs)
      :classmethod:
