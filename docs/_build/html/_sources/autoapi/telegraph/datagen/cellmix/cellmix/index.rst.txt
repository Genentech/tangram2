telegraph.datagen.cellmix.cellmix
=================================

.. py:module:: telegraph.datagen.cellmix.cellmix


Functions
---------

.. autoapisummary::

   telegraph.datagen.cellmix.cellmix._update_adatas
   telegraph.datagen.cellmix.cellmix._add_interactions
   telegraph.datagen.cellmix.cellmix._linear_grad
   telegraph.datagen.cellmix.cellmix._add_gradients
   telegraph.datagen.cellmix.cellmix._generate_coords
   telegraph.datagen.cellmix.cellmix._cellmix_type_balanced
   telegraph.datagen.cellmix.cellmix._downsample
   telegraph.datagen.cellmix.cellmix.cellmix


Module Contents
---------------

.. py:function:: _update_adatas(ad_sc, ad_sp, x_add_sc, sc_var)

.. py:function:: _add_interactions(adata: anndata.AnnData, n_effect: int = 10, spatial_key: str = 'spatial', subset_types: List[str] | None = None, p_active_spots: float = 0.2, p_inter: float = 0.5, spot_data: bool = True, signal_name: str | None = None, return_names: bool = True, subset_features: List[str] | None = None, active_coef: float | Tuple[float, float] | None = None, signal_effect_base: float | Tuple[float, float] | None = None, direction: Literal['up', 'down', 'both'] = 'up')

.. py:function:: _linear_grad(crd, mu_low, mu_high, rad_theta)

.. py:function:: _add_gradients(adata: anndata.AnnData, n_features: int | float, return_names: bool = True)

.. py:function:: _generate_coords(p_mat: numpy.ndarray, encode_spatial: bool = True)

.. py:function:: _cellmix_type_balanced(ad_sc: anndata.AnnData, n_spots: int, n_cells_per_spot: int = 10, n_types_per_spot: int = 3, label_col: str | None = None, add_spatial_structure: bool = True, encode_spatial: bool = False, n_spatial_grad: None | int = None, n_interactions: int | None = None, effect_size: int = 10, p_signal_spots: float = 0.5, p_inter: float = 0.5, signal_effect_scaling: float | Tuple[float, float] | None = None, signal_effect_base: float | Tuple[float, float] | None = None, effect_direction: Literal['up', 'down', 'both'] = 'up')

   creates 'mixed' data akin to spot-based data that will have a pre-specified
   average number of cell types per spot as well as pre-defined number of cells per spot



.. py:function:: _downsample(adata: anndata.AnnData, downsample: List[float] | float | None = None)

   downsamples exprssion according to a given percentage.
   the new library size of each observation will be downsample % of the original one.



.. py:function:: cellmix(ad_sc: anndata.AnnData, n_spots: int, n_cells_per_spot: int = 10, n_types_per_spot: int = 3, label_col: str | None = None, downsample: List[float] | float | None = None, encode_spatial: bool = False, n_spatial_grad: None | int = None, n_interactions: bool | None = None, effect_size: int = 10, p_signal_spots: float = 0.5, p_inter: float = 0.5, signal_effect_scaling: float | Tuple[float, float] | None = None, signal_effect_base: float | Tuple[float, float] | None = None, effect_direction: Literal['up', 'down', 'both'] = 'up')

   pretty wrapper for cellmix

   :param ad_sc: AnnData object containing the data to use for synthetic data generation
   :param n_spots: number of spots in the synthetic data
   :param n_cells_per_spot: desired average number of cells per spot
   :param n_types_per_spot: desired average number of types per spot
   :param label_col: column in `ad_sc.obs` that holds cell type label information
   :param downsample: this downsamples the transcripts in the spatial data so it's not a perfect match
   :param encode_spatial: this makes the data spatially organized. Spots with similar cell type proportion as closer to each other.
   :param n_spatial_grad: this adds artificial genes that have clear spatial patterns.
   :param effect_size: number of genes in each effect from a given signal
   :param p_signal_spots: percentage of spots where interactions happen
   :param p_inter: percentage of cells that could interact (i.e. they are not signalers, and they are proximal to a signaler cell) that actually will interact
   :param signal_effect_scaling: the gene expression ratio for the effects and signals in signaling/receiving cells vs non-signaling/non-receiving cells
   :param signal_effect_base: the base expression level. You specify this as a number of [0,1] which indicates which quantile you want the base level expression of the signal/effects to be in (w.r.t. to all other genes) - note base level expression is scaled by the signal_effect_scaling factor in signaling/receiving genes
   :param effect_direction: up - only up-regulated genes, down - only down-regulated genes, both - 50/50 up and sown regulated genes

   Returns:

   A tuple (ad_sp,ad_sc) that contains the synthetic spatial and single cell data respectively.

   Information about aritifically added genes can be found in `ad_sc.var`.

   Information about signaling and receiving cells can be found in `ad_sc.obs`.

   Cell type proportions and number are found in `ad_sp.obsm`.
